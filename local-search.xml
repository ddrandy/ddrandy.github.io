<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM 架构原理浅谈</title>
    <link href="/2022/04/07/jvm-abc/"/>
    <url>/2022/04/07/jvm-abc/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来讲一下JVM原理，记录下自己对 JVM 的理解和认知。<br>理解 JVM 架构设计和 Java 的工作原理对我们每一个 Java 开发人员来说都是非常重要的一课。想要进一步提升和突破自己技术上的瓶颈，就要加深对 Java 基础掌握。这相当于建房子时要夯实地基。你的房子能稳定盖多高，取决于地基打的有多牢。同样的，你的 Java 之路能走多远，除了业务因素，还取决于对原理的掌握，换言之，要抓到 Java 程序运行的本质。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1995年 James Gosling 给 Sun 公司的 Microsystems 系统设计了 Java 编程语言。由于 Java 语言的一系列特点（跨平台，面向对象，结构化，垃圾回收，强类型和支持并发，反射，范型等等）和 WORA(write once, run anywhare) 设计理念而不断流行至今。<br>为了支持 WORA 的设计理念，Java 语言的编译产物是一份操作平台无关的字节码格式 class 文件。而相应的要运行这份编译产物，Sun 公司（5.0 之后由 Java 社区）制定和维护了一套 Java 虚拟机技术规范。</p><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E6%A9%9F%E5%99%A8">虚拟机</a></h4><p>虚拟机，是指一种特殊的软件，在计算机平台和终端用户之间创建一种环境，终端用户基于虚拟机这个软件所创建的环境来操作运行在上面的其它软件。</p><h4 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA">Java 虚拟机</a></h4><p>Java 虚拟机（Java Virtual Machine），是一种能够执行 Java 字节码的虚拟机。</p><p>JVM 是一套规范标准，它的实现可能会因组织或公司而异。比如开源方案 OpenJDK 和 Oracle 的商业化实现。<br>如果精力允许，你我都可以写一套自己的 JVM 程序。</p><p>由于 JVM 是一套遵循 Java 字节码运行规范的虚拟机系统，所以只要编程语言的编译产物为合法的 Java 字节码，就可以在 JVM 上运行。<br>如以下常见原生基于 JVM 的语言：</p><ul><li>Java</li><li>Groovy</li><li>Kotlin</li><li>Scala</li></ul><h2 id="JVM-架构"><a href="#JVM-架构" class="headerlink" title="JVM 架构"></a>JVM 架构</h2><p>有兴趣可以翻翻 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/">Java 虚拟机技术规范</a>，其中详细描述了 JVM 的设计规范要求。不过不包括实现细节。</p><blockquote><p>Implementation details that are not part of the Java Virtual Machine’s specification would unnecessarily constrain the creativity of implementors. </p></blockquote><img src="/2022/04/07/jvm-abc/jvm_architecture.png" class=""><h3 id="类加载系统"><a href="#类加载系统" class="headerlink" title="类加载系统"></a>类加载系统</h3><p>在 JVM 开始运行后会驻留在内存当中并按 JVM 架构图中所示分配不同的内存空间。执行期间会通过类加载系统将 class 文件加载到内存，称为<strong>动态类加载机制</strong>。在运行期间第一次加载类时，会完成该 class 的加载，链接和初始化过程。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类加载器的主要功能是将编译好的 class 文件加载到内存当中。通常类的加载从加载 <code>main class</code>（包含静态 main 方法的类）开始。所有后续的类加载都是根据已经加载运行的类中的引用完成。比如：</p><ul><li>静态引用了一个类的属性<code>System.out</code></li><li>创建一个类对象<code>new HashMap()</code></li></ul><p>Java 提供了三种类加载器，通过继承关系连接起来，它们遵循如下原则。</p><ol><li><p>可见性原则<br>子类加载器可以访问父类加载器加载的类，但是父类加载器无法访问子类加载器加载的类。</p></li><li><p>唯一性原则<br>父类加载的类不应该被子类加载器加载，同一个类不应该发生重复的类加载过程。</p></li><li><p>委托原则<br>为满足上述两条原则，JVM 遵循委托的层次结构来为每个类加载请求选择类加载器。从继承关系的子类开始，<code>ApplicationClassLoader</code> 将接收到的类加载请求委托给 <code>ExtensionClassLoader</code>，然后 <code>ExtensionClassLoader</code> 将加载请求委托给<code>BootstrapClassLoader</code>。<br>如果在 <code>BootstrapClassLoader</code> 路径中找到请求的类，则加载并返回改类。否则，加载请求返回到 <code>ExtensionClassLoader</code> 中从其路径查找该类。如果加载也失败了，请求会返回到 <code>ApplicationClassLoader</code> 中查找，如果它也没有成功加载到请求的类，会抛出运行时异常 <code>java.lang.ClassNotFoundException</code>。</p></li></ol><p>除了上述三个类加载器，开发者也可以创建自定义的类加载器。选择遵照或打破上述原则来实现更加定制化的功能。</p><p>每个类加载器有它的<strong>命名空间</strong>，用以存储其加载的类字节码。当一个类加载器加载类时，通过该类的完全限定类名从命名空间查找是否已经加载过。如果两个类有相同的完全限定类名，但存储在不同的命名空间当中，也会被作为两个不同的类。不同的命名空间意味着是由不同的类加载器加载到内存当中。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接是获取类或接口并将其组合到 JVM 的运行时状态的过程。类经过连接过程后才能够被 JVM 执行。链接一个类或接口包括验证和准备这个类或接口，如有必要，也包括它的直接父类，直接父接口和其元素类型（如果链接对象是一个数组）。链接过程中，解析类或接口的符号引用是一个可选部分。</p><p><em>链接的规范</em></p><ol><li>类或接口必须完成加载才可以进行链接。</li><li>类或接口必须完成校验和准备才可以完成后续初始化。</li><li>如果连接过程出现错误，将会在程序执行到直接或间接涉及到该类或接口链接过程的必要环节时抛出错误。</li></ol><p><strong>链接包括分配新的数据结构，因此可能会失败并抛出 <code>OutOfMemoryError</code>。</strong></p><h5 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h5><p>校验确保类或接口的 class 文件在结构上是正确的。这是类加载过程中最复杂的测试过程，也是耗时最长的。尽管它减慢了类加载的过程，但它避免了在执行字节码时多次进行这些检查的环节，从而使整体执行高效和有效。如果校验失败，会抛出运行时错误 <code>java.lang.VerifyError</code>。</p><p>校验过程可能包含如下环节：</p><ul><li>一致且格式正确的符号表</li><li><code>final</code> 方法或类没有被重载</li><li>类或方法调用遵照访问控制关键字限制</li><li>方法的参数类型和个数正确</li><li>字节码指令没有错误的堆栈操作</li><li>变量在访问前完成初始化</li><li>变量类型正确</li></ul><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>  准备阶段会进行内存分配，包括为类或接口创建静态字段并将这些字段初始化为默认值。这里不需要执行任何 Java 虚拟机代码；静态字段的显式初始化将在链接之后的初始化环节完成，而不是在准备阶段。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析是从运行时常量池中的直接引用替换符号引用的过程。它是通过搜索方法区来定位引用的实体来完成的。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类或接口的初始化包括执行其初始化方法 <code>&lt;clinit&gt;</code>。<br>此阶段将执行每个加载的类或接口的初始化逻辑，比如调用类的构造函数。由于 JVM 是多线程的，因此类或接口的初始化应该非常谨慎，避免多个线程同时尝试初始化同一个类或接口（使其成为线程安全的）。</p><p>初始化是类加载的最后阶段，其中所有变量都会分配其代码中定义的初始值，并执行静态代码块。<br>初始化的执行顺序在层次结构中从父类到子类逐级执行，类的内部从上到下逐行执行。</p><p><strong>下面代码的输出日志你清楚吗？</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constructTest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test a:&quot;</span> + TestClass.a);<br>        System.out.println(<span class="hljs-string">&quot;test b:&quot;</span> + TestClass.b);<br>        System.out.println(<span class="hljs-string">&quot;test c:&quot;</span> + TestClass.c);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test block b&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static block called&quot;</span>);<br>    &#125;<br><br>    TestClass() &#123;<br>        System.out.println(<span class="hljs-string">&quot;constructor called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><details><summary><i>查看结果</i></summary><div class="hljs code-wrapper"><pre><code class="hljs">test a:3test b:test block bstatic block calledtest c:java.lang.Object@4f6b3a3f</code></pre></div>和你想的一样吗？</details><br/><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><h4 id="运行时编译器"><a href="#运行时编译器" class="headerlink" title="运行时编译器"></a>运行时编译器</h4><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h3 id="Java-本地接口（JNI）"><a href="#Java-本地接口（JNI）" class="headerlink" title="Java 本地接口（JNI）"></a>Java 本地接口（JNI）</h3><h3 id="本地方法库"><a href="#本地方法库" class="headerlink" title="本地方法库"></a>本地方法库</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">Chapter 2. The Structure of the Java Virtual Machine</a></li><li><a href="https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722">Understanding JVM Architecture</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2022/04/06/first-blog/"/>
    <url>/2022/04/06/first-blog/</url>
    
    <content type="html"><![CDATA[<p>终于开坑建了自己的博客。<br>以后会不定期更新，用来记录生命中的点点滴滴，希望能够培养成一个习惯。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hello world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
